<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{TIMELINE_TITLE}}</title>

    <!-- vis-timeline CSS (standalone build - the old graph2d build is deprecated) -->
    <link href="https://unpkg.com/vis-timeline/standalone/umd/vis-timeline-graph2d.min.css" rel="stylesheet">
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="container">
        <header>
            <h1>{{TIMELINE_TITLE}}</h1>
            <p class="subtitle">{{TIMELINE_SUBTITLE}}</p>
        </header>

        <div class="filter-controls">
            {{FILTER_BUTTONS}}
        </div>

        <!-- Navigation Controls -->
        <div class="zoom-controls">
            <button class="zoom-btn" onclick="panLeft()" title="Pan Left">◀</button>
            <button class="zoom-btn" onclick="zoomOut()" title="Zoom Out">−</button>
            <button class="zoom-btn fit-btn" onclick="fitAll()" title="Fit All">Fit All</button>
            <button class="zoom-btn" onclick="zoomIn()" title="Zoom In">+</button>
            <button class="zoom-btn" onclick="panRight()" title="Pan Right">▶</button>
        </div>

        <div id="timeline"></div>

        <p class="instructions">Use ◀ ▶ buttons to pan | Use + − buttons to zoom | Click an event for details</p>

        <div class="info-panel">
            <div class="legend">
                <h3>Timeline Categories</h3>
                {{LEGEND_ITEMS}}
            </div>

            <div class="event-details">
                <h3>Event Details</h3>
                <div id="details-content">
                    <p class="placeholder">Click on a timeline event to see its full details here.</p>
                </div>
            </div>
        </div>
    </div>

    <!-- vis-timeline JavaScript (standalone build - the old graph2d build is deprecated) -->
    <script src="https://unpkg.com/vis-timeline/standalone/umd/vis-timeline-graph2d.min.js"></script>

    <script>
        // Color scheme for categories
        const categoryColors = {{CATEGORY_COLORS}};

        let timeline;
        let timelineData;
        let allItems = [];
        let currentFilter = 'all';

        // Load timeline data
        fetch('timeline.json')
            .then(response => response.json())
            .then(data => {
                initializeTimeline(data);
            })
            .catch(error => {
                console.error('Error loading timeline data:', error);
                document.getElementById('timeline').innerHTML =
                    '<p style="padding: 20px; color: #e74c3c;">Error loading timeline data. Please ensure timeline.json exists.</p>';
            });

        function initializeTimeline(data) {
            // Convert JSON events to vis-timeline format
            allItems = data.events.map((event, index) => {
                const year = parseInt(event.start_date.year);
                const month = parseInt(event.start_date.month || 1) - 1;
                const day = parseInt(event.start_date.day || 1);

                return {
                    id: `event-${index}`,
                    content: event.text.headline,
                    start: new Date(year, month, day),
                    title: `<div style="max-width: 280px; word-wrap: break-word; overflow-wrap: break-word; white-space: normal;">${event.notes || event.text.text}</div>`,
                    className: event.group.replace(/\s+/g, '-').toLowerCase(),
                    style: `background-color: ${categoryColors[event.group]}; color: white; border-color: ${categoryColors[event.group]};`,
                    category: event.group,
                    displayDate: event.start_date.display_date || `${year}`,
                    eventData: event
                };
            });

            // Calculate min/max dates for initial window
            const dates = allItems.map(item => item.start.getTime());
            const minDate = Math.min(...dates);
            const maxDate = Math.max(...dates);

            // Create a DataSet
            timelineData = new vis.DataSet(allItems);

            // =========================================================================
            // EDGE CLIPPING PREVENTION - JavaScript Configuration
            // =========================================================================
            // Problem: vis-timeline clips event boxes when they extend beyond the
            // visible date range, especially for events near the left/right edges.
            //
            // Solution (Part 1 of 3): Configure margins and alignment options
            // - margin.item.horizontal: Adds 50px buffer around each item
            // - align: 'center': Centers items on their date point so text extends
            //   equally in both directions, reducing edge overflow
            // =========================================================================
            const options = {
                width: '100%',
                height: '400px',
                margin: {
                    item: { horizontal: 50, vertical: 10 },  // Explicit horizontal margin for edge padding
                    axis: 40
                },
                orientation: 'top',
                zoomMin: 1000 * 60 * 60 * 24 * 365 * {{ZOOM_MIN_YEARS}},
                zoomMax: 1000 * 60 * 60 * 24 * 365 * {{ZOOM_MAX_YEARS}},
                min: new Date({{MIN_YEAR}}, 0, 1),
                max: new Date({{MAX_YEAR}}, 0, 1),
                tooltip: {
                    followMouse: true
                },
                stack: true,
                selectable: true,
                showCurrentTime: false,
                moveable: true,
                zoomable: false,             // Disable scroll-wheel zoom to not interfere with page scrolling
                align: 'center'              // Center items on their date point
            };

            // Create timeline
            const container = document.getElementById('timeline');
            timeline = new vis.Timeline(container, timelineData, options);

            // Handle event selection
            timeline.on('select', function(properties) {
                if (properties.items.length > 0) {
                    const itemId = properties.items[0];
                    const item = allItems.find(i => i.id === itemId);
                    if (item) {
                        showEventDetails(item.eventData);
                    }
                }
            });

            // =========================================================================
            // EDGE CLIPPING PREVENTION - Window Padding (Part 2 of 3)
            // =========================================================================
            // Problem: Using timeline.fit() sets the window exactly to the data range,
            // causing the first and last events to be positioned at the very edge
            // where their text boxes get clipped.
            //
            // Solution: Manually set the visible window with 2-year padding on each
            // side instead of using fit(). This ensures edge events have room to
            // render their full text boxes without clipping.
            // =========================================================================
            const twoYears = 2 * 365 * 24 * 60 * 60 * 1000;
            timeline.setWindow(
                new Date(minDate - twoYears),
                new Date(maxDate + twoYears),
                { animation: false }
            );
        }

        function filterCategory(category) {
            currentFilter = category;

            // Update button states
            document.querySelectorAll('.filter-btn').forEach(btn => {
                btn.classList.remove('active');
            });

            let itemsToShow;
            if (category === 'all') {
                document.querySelector('.filter-btn.all').classList.add('active');
                itemsToShow = [...allItems];
            } else {
                // Find the button with matching data-category
                const btn = document.querySelector(`.filter-btn[data-category="${category}"]`);
                if (btn) btn.classList.add('active');
                itemsToShow = allItems.filter(item => item.category === category);
            }

            timelineData.clear();
            timelineData.add(itemsToShow);

            // =========================================================================
            // EDGE CLIPPING PREVENTION - Filter Window Padding
            // =========================================================================
            // When filtering by category, we must also apply the 2-year padding
            // to prevent edge clipping on the filtered subset of events.
            // =========================================================================
            if (itemsToShow.length > 0) {
                const dates = itemsToShow.map(item => item.start.getTime());
                const minDate = Math.min(...dates);
                const maxDate = Math.max(...dates);

                // Add 2 years padding on each side
                const twoYears = 2 * 365 * 24 * 60 * 60 * 1000;
                timeline.setWindow(
                    new Date(minDate - twoYears),
                    new Date(maxDate + twoYears),
                    { animation: false }
                );
            }
        }

        function showEventDetails(event) {
            const displayDate = event.start_date.display_date || event.start_date.year;
            const categoryColor = categoryColors[event.group];

            const html = `
                <div class="event-title">${event.text.headline}</div>
                <div class="event-date">
                    <span>${displayDate}</span>
                    <span class="event-category" style="background: ${categoryColor};">${event.group}</span>
                </div>
                <div class="event-description">${event.text.text}</div>
                ${event.notes ? `
                <div class="event-context">
                    <div class="event-context-label">Historical Context</div>
                    <div class="event-context-text">${event.notes}</div>
                </div>
                ` : ''}
            `;

            document.getElementById('details-content').innerHTML = html;
        }

        // =========================================================================
        // Navigation Control Functions
        // =========================================================================
        // These provide explicit zoom/pan controls since scroll-wheel zoom is
        // disabled to avoid interfering with page scrolling.
        // =========================================================================
        function zoomIn() {
            if (timeline) {
                const range = timeline.getWindow();
                const interval = range.end - range.start;
                const newInterval = interval * 0.5; // Zoom in by 50%
                const center = new Date((range.start.getTime() + range.end.getTime()) / 2);
                timeline.setWindow(
                    new Date(center.getTime() - newInterval / 2),
                    new Date(center.getTime() + newInterval / 2)
                );
            }
        }

        function zoomOut() {
            if (timeline) {
                const range = timeline.getWindow();
                const interval = range.end - range.start;
                const newInterval = interval * 2; // Zoom out by 200%
                const center = new Date((range.start.getTime() + range.end.getTime()) / 2);
                timeline.setWindow(
                    new Date(center.getTime() - newInterval / 2),
                    new Date(center.getTime() + newInterval / 2)
                );
            }
        }

        function fitAll() {
            if (timeline) {
                // Get visible items and manually set window with padding
                const visibleItems = timelineData.get();
                if (visibleItems.length > 0) {
                    const dates = visibleItems.map(item => item.start.getTime());
                    const minDate = Math.min(...dates);
                    const maxDate = Math.max(...dates);

                    const twoYears = 2 * 365 * 24 * 60 * 60 * 1000;
                    timeline.setWindow(
                        new Date(minDate - twoYears),
                        new Date(maxDate + twoYears),
                        { animation: false }
                    );
                }
            }
        }

        function panLeft() {
            if (timeline) {
                const range = timeline.getWindow();
                const interval = range.end - range.start;
                const shift = interval * 0.3; // Pan by 30% of visible range
                timeline.setWindow(
                    new Date(range.start.getTime() - shift),
                    new Date(range.end.getTime() - shift)
                );
            }
        }

        function panRight() {
            if (timeline) {
                const range = timeline.getWindow();
                const interval = range.end - range.start;
                const shift = interval * 0.3; // Pan by 30% of visible range
                timeline.setWindow(
                    new Date(range.start.getTime() + shift),
                    new Date(range.end.getTime() + shift)
                );
            }
        }
    </script>
</body>
</html>
